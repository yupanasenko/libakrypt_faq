
   
FAQ по библиотеке libakrypt
====================================================

Как написать самую простую программу
------------------------------------


Есть ли базовый шаблон программы?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Программа, использующая библиотеку, должна в обязательном порядке выполнить два простых действия:

  * инициализировать библиотеку с помощью функии ``ak_libakrypt_create()``,
  * после окончания криптографических преобразований выполнить функцию ``ak_libakrypt_destroy()``.

Базовый шаблон программы выглядит следующим образом (файл `example-0.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-0.c>`_).


Как отследить ошибки при выполнении библиотечных функций?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для отслеживания ошибок при работе с библиотечными функциями необходимо использовать функцию ``ak_error_get_value()``.

*Увидеть примеры ее использования можно во всех примерах раздела FAQ.*


Где посмотреть перечисление ошибок и их кодов для проведения аудита?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Посмотреть все коды ошибок можно в файле `libakrypt-base.h <https://github.com/yupanasenko/libakrypt_faq/blob/master/source/libakrypt-base.h.in>`_ со строки 200.


БЛОЧНЫЕ ШИФРЫ
----------------

Процесс зашифрования данных блочным шифром состоит из следующих шагов:

	1. Определение параметров шифрования (теоретическая часть);
	
	2. Определение открытого текста и выделение памяти под зашифрованный текст;
	
	3. Создание контекста ключа блочного шифрования ``ak_bckey``;
	
	4. Инициализация секретного ключа блочного шифрования;
	
	5. В случае, если необходима синхропосылка или имитовставка - создание синхропосылки или выработка имитовставки;
	
	6. Зашифрование открытого текста;
	
	7. Уничтожение структуры ``ak_bckey``.
	

Как создать контекст ключа блочного шифрования?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Контекст ключа ``ak_bckey`` – основная структура данных в разделе блочного шифрования.

После завершения работы с данной структурой - ее **необходимо уничтожить** функцией ``int ak_bckey_destroy( ak_bckey bkey )``!


Создать ее можно несколькими способами:

	1. Инициализация контекста ключа значением, выработанным из заданного значения пароля при помощи алгоритма PBKDF2, описанного  в рекомендациях по стандартизации Р 50.1.111-2016 (Пароль должен быть непустой строкой символов в формате utf8):

:: 

	int ak_bckey_set_key_from_password(
		ak_bckey bkey, /*Контекст ключа алгоритма блочного шифрования*/
		const ak_pointer pass, /*Пароль, представленный в виде строки символов*/
		const size_t pass_size, /*Длина пароля в байтах*/
		const ak_pointer salt, /*Случайный вектор, представленный в виде строки символов.*/
		const size_t salt_size /*Длина случайного вектора в байтах*/
		)

*Использование функции можно увидеть в следующих примерах:* `example-1 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-1.c>`_, `example-2 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-2.c>`_.


	2. Инициализация контекста ключа случайным (псевдо-случайным) значением, выработанным генератором псевдо-случайных чисел:

::

	int ak_bckey_set_key_random(
		ak_bckey bkey, /*Контекст ключа алгоритма блочного шифрования*/
		ak_random generator /*Контекст генератора случайных (псевдослучайных) чисел*/
		)


*Использование функции можно увидеть в следующих примерах:* `example-3 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-3.c>`_, `example-4 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-4.c>`_.


	3. Инициализация контекста ключа значением, содержащимся в области памяти: 
::

	int ak_bckey_set_key(
			ak_bckey bkey, /*Контекст ключа алгоритма блочного шифрования*/
			const ak_pointer keyptr, /*Строка содержащая значение ключа*/
			const size_t size /*Размер строки со значением ключа*/
			)
			
*Использование функции можно увидеть в следующих примерах:* `example-5 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-5.c>`_, `example-6 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-6.c>`_.




Как создать секретный ключ алгоритма блочного шифрования?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Создать секретный ключ можно несколькими способами:

	1. С помощью функции алгоритма Магма:
:: 

	int ak_bckey_create_magma(ak_bckey bkey);

*Использование функции можно увидеть в следующих примерах:* `example-5 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-5.c>`_, `example-6 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-6.c>`_, `example-7 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-7.c>`_.

	2. С помощью функции алгоритма Кузнечик:
:: 
	
	int ak_bckey_create_kuznechik(ak_bckey bkey);

*Использование функции можно увидеть в следующих примерах:* `example-3 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-5.c>`_, `example-7 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-6.c>`_.


	3. По OID алгоритма:
::
	
	int ak_bckey_create_oid(ak_bckey bkey, ak_oid oid);
	
	/* Возможные значения OID для шифрования:
    
   	"magma"
	"kuznechik"
    
        Все OID аналогичны заданию функции напрямую */  


*Использование функции можно увидеть в следующих примерах:* `example-1 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-1.c>`_, `example-2 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-2.c>`_.



Как зашифровать/расшифровать данные в режиме простой замены (electronic codebook, ecb)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зашифровать текст в режиме простой замены (ecb) можно с помощью следующей функции: 

::

	int ak_bckey_encrypt_ecb(
		ak_bckey bkey, /*Контекст ключа алгоритма блочного шифрования*/
		ak_pointer in, /*Указатель на область памяти, где хранятся данные для зашифрования */
		ak_pointer out,  /*Указатель на область памяти, куда помещаются зашифрованные данные*/
		size_t size   /* Размер зашифровываемых данных (в байтах)*/
		)


Расшифровать в режиме простой замены (ecb) можно с помощью функции, аналогичной зашифрованию:

:: 

	int ak_bckey_decrypt_ecb(
		ak_bckey bkey, /*Контекст ключа алгоритма блочного шифрования*/
		ak_pointer in, /*Указатель на область памяти, где хранятся данные для зашифрования */
		ak_pointer out,  /*Указатель на область памяти, куда помещаются зашифрованные данные*/
		size_t size   /* Размер зашифровываемых данных (в байтах)*/
		)

*Использование функций можно увидеть в следующем примере:* `example-1 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-1.c>`_.


Как зашифровать/расшифровать данные в режиме гаммирования – из ГОСТ Р 34.13-2015 (counter mode, ctr)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зашифровать и расшифровать текст в режиме гаммирования (ctr) можно с помощью следующей функции (она выполняет оба действия):
::

	int ak_bckey_ctr(
        	ak_bckey bkey, /*Контекст ключа алгоритма блочного шифрования, на котором происходит 
        	зашифрование или расшифрование информации*/
        	ak_pointer in, /*Указатель на область памяти, где хранятся входные (зашифрованные) данные*/
        	ak_pointer out, /*Указатель на область памяти, куда помещаются зашифрованные(расшифрованные) данные 
        	(может быть тем же указателем, что и указатель на открытые данные )*/
        	size_t size, /*Размер зашировываемых (расшифровываемых) данных (в байтах)*/
        	ak_pointer iv, /*Указатель на произвольную область памяти - синхропосылку. 
        	Область памяти не изменяется*/
        	size_t iv_size /*Длина синхропосылки в байтах*/
        	)


*Использование функции можно увидеть в следующем примере:* `example-2.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-2.c>`_.



Как зашифровать/расшифровать данные в режиме гаммирования с обратной связью по выходу (output feedback, ofb)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зашифровать и расшифровать текст в режиме гаммирования с обратной связью по выходу (ofb) можно с помощью следующей функции:
::

	int ak_bckey_ofb(
    		ak_bckey bkey, /*Контекст ключа алгоритма блочного шифрования, на котором происходит 
        	зашифрование или расшифрование информации*/
        	ak_pointer in, /*Указатель на область памяти, где хранятся входные (зашифрованные) данные*/
        	ak_pointer out, /*Указатель на область памяти, куда помещаются зашифрованные(расшифрованные) данные 
        	(может быть тем же указателем, что и указатель на открытые данные )*/
        	size_t size, /*Размер зашировываемых (расшифровываемых) данных (в байтах)*/
        	ak_pointer iv, /*Указатель на произвольную область памяти - синхропосылку. 
        	Область памяти не изменяется*/
        	size_t iv_size /*Длина синхропосылки в байтах*/
    		)
		
*Использование функции можно увидеть в следующем примере:* `example-3.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-3.c>`_.


Как зашифровать/расшифровать данные в режиме гаммирования с обратной связью по шифртексту из ГОСТ Р 34.13-2015 (cipher feedback, cfb)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зашифровать и расшифровать текст в режиме гаммирования с обратной связью по шифртексту (cfb) можно с помощью следующей функции:
::

	int ak_bckey_encrypt_cfb(
    		ak_bckey bkey, /*Контекст ключа алгоритма блочного шифрования, на котором происходит 
        	зашифрование или расшифрование информации*/
        	ak_pointer in, /*Указатель на область памяти, где хранятся входные (зашифрованные) данные*/
        	ak_pointer out, /*Указатель на область памяти, куда помещаются зашифрованные(расшифрованные) данные 
        	(может быть тем же указателем, что и указатель на открытые данные )*/
        	size_t size, /*Размер зашировываемых (расшифровываемых) данных (в байтах)*/
        	ak_pointer iv, /*Указатель на произвольную область памяти - синхропосылку. 
        	Область памяти не изменяется*/
        	size_t iv_size /*Длина синхропосылки в байтах*/
    		)


*Использование функции можно увидеть в следующем примере:* `example-4.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-4.c>`_.


Как зашифровать/расшифровать данные в режиме «CTR-ACPKM» из Р1323565.1.017—2018?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зашифровать и расшифровать текст в режиме «CTR-ACPKM» (acpkm) можно с помощью следующей функции:
::

	int ak_bckey_ctr_acpkm(
    		ak_bckey bkey, /*Контекст ключа алгоритма блочного шифрования,
    		используемый для шифрования и порождения цепочки производных ключей.*/
    		ak_pointer in, /*Указатель на область памяти, где хранятся входные
    		зашифровываемые (расшифровываемые) данные*/
    		ak_pointer out, /*Указатель на область памяти, куда помещаются выходные данные*/
    		size_t size, /*размер зашировываемых (расшифровываемых) данных (в байтах)*/
    		size_t section_size, /*Размер одной секции в байтах. Данная величина должна быть кратна длине блока
    		используемого алгоритма шифрования.*/
    		ak_pointer iv, /*имитовставка*/
    		size_t iv_size /*длина имитовставки в байтах*/
    		)

*Использование функции можно увидеть в следующем примере:* `example-5.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-5.c>`_.



Как зашифровать/расшифровать данные в режиме «XTS»?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зашифровать текст в режиме «XTS» (xtsmac) можно с помощью следующей функции:
::

	int ak_bckey_encrypt_xtsmac(
		ak_pointer encryptionKey,/*ключ шифрования*/
     		ak_pointer authenticationKey, /*ключ выработки кода аутентификации (имитовставки)*/
     		const ak_pointer adata, /*указатель на ассоциируемые данные*/
     		const size_t adata_size, /*размер ассоциируемых данных в байтах*/
     		const ak_pointer in, /*указатель на зашифровываемые данные*/
     		ak_pointer out, /*указатель на зашифрованные данные*/
     		const size_t size, /*размер зашифровываемых данных в байтах, должен быть не менее 16 октетов*/
     		const ak_pointer iv, /*указатель на синхропосылку*/
     		const size_t iv_size, /*длина синхропосылки в байтах*/
     		ak_pointer icode, /*указатель на область памяти, куда будет помещено значение имитовставки*/
     		const size_t icode_size /*ожидаемый размер имитовставки в байтах; значение не должно превышать 16 октетов*/
     		)

Расшифровать текст в режиме «XTS» (xtsmac) можно с помощью функции, аналогичной зашифрованию:
::

	int ak_bckey_decrypt_xtsmac(
		ak_pointer encryptionKey,/*ключ шифрования*/
     		ak_pointer authenticationKey, /*ключ выработки кода аутентификации (имитовставки)*/
     		const ak_pointer adata, /*указатель на ассоциируемые данные*/
     		const size_t adata_size, /*размер ассоциируемых данных в байтах*/
     		const ak_pointer in, /*указатель на расшифровываемые данные*/
     		ak_pointer out, /*указатель на область памяти куда будут помещены расшифрованные данные*/
     		const size_t size, /*размер расшифровываемых данных в байтах, должен быть не менее 16 октетов*/
     		const ak_pointer iv, /*указатель на синхропосылку*/
     		const size_t iv_size, /*длина синхропосылки в байтах*/
     		ak_pointer icode, /*указатель на область памяти, куда будет помещено значение имитовставки*/
     		const size_t icode_size /*ожидаемый размер имитовставки в байтах; значение не должно превышать 16 октетов;*/
		)

*Использование функций можно увидеть в следующем примере:* `example-6.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-6.c>`_.



Как зашифровать/расшифровать данные в режиме простой замены с зацеплением из ГОСТ Р 34.13-2015 (cipher block chaining, cbc)?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Зашифровать текст в режиме простой замены (cbc) можно с помощью следующей функции: 

::

	int ak_bckey_encrypt_cbc(
		ak_bckey bkey, /* Контекст ключа алгоритма блочного шифрования */
		ak_pointer in, /* Указатель на область памяти, где хранятся данные для зашифрования */
		ak_pointer out,  /* Указатель на область памяти, куда помещаются зашифрованные данные */
		size_t size,  /* Размер зашифровываемых данных (в байтах) */
		ak_pointer iv, /* Указатель на произвольную область памяти - синхропосылку */
		size_t iv_size /* Длина синхропосылки в байтах. Согласно  стандарту ГОСТ Р 34.13-2015 длина
		синхропосылки должна быть ровно в два раза меньше, чем длина блока, 
		то есть 4 байта для Магмы и 8 байт для Кузнечика.*/
		);

Предварительно необходимо создать синхропосылку, передаваемую в качестве аргумента в описанную выше функцию.

Пример синхропосылки:

::

	ak_uint8 openssl_ivcbc[32] = {
		0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 
		0xa1, 0xb2, 0xc3, 0xd4, 0xe5, 0xf0, 0x01, 0x12, 
		0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x90, 
		0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19
		};

Расшифровать текст в режиме простой замены (cbc) можно с помощью функции, аналогичной зашифрованию: 

::

	int ak_bckey_decrypt_cbc(
		ak_bckey bkey, /* Контекст ключа алгоритма блочного шифрования*/
		ak_pointer in, /* Указатель на область памяти, где хранятся данные для зашифрования */
		ak_pointer out, /* Указатель на область памяти, куда помещаются зашифрованные данные */
		size_t size /* Размер зашифровываемых данных (в байтах) */
		ak_pointer iv, /* Указатель на произвольную область памяти - синхропосылку */
		size_t iv_size /*Длина синхропосылки в байтах. Согласно  стандарту ГОСТ Р 34.13-2015 длина 
		синхропосылки должна быть ровно в два раза меньше, чем длина блока, 
		то есть 4 байта для Магмы и 8 байт для Кузнечика */
		);

*Использование функций можно увидеть в следующем примере:* `example-7.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-7.c>`_.



АЛГОРИТМ AEAD
----------------------------------------------------
Процесс зашифрования данных аутентифицированным шифрованием состоит из следующих шагов:

	1. Определение параметров шифрования (теоретическая часть);
	
	2. Определение открытого текста и выделение памяти под зашифрованный текст;
	
	3. Создание контекста ключа аутентифицированного шифрования ``ak_aead``;
	
	4. Инициализация ключей шифрования и аутентификации аутентифицированного шифрования;
	
	5. В случае, если необходима синхропосылка или имитовставка - создание синхропосылки или выработка имитовставки;
	
	6. Зашифрование открытого текста;
	
	7. Уничтожение структуры ``ak_aead``.

Как создать контекст алгоритма аутентифицированного шифрования?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Контекст ключа ``ak_aead`` – основная структура данных в разделе аутентифицированного шифрования.

После завершения работы с данной структурой - ее **необходимо уничтожить** функцией ``int ak_aead_destroy( ak_aead ctx )``!

В данной библиотеке описано 12 функций для создания контекста алгоритма аутентифицированного шифрования. Коротко рассмотрим каждую из них здесь.

	1. Создание контекста алгоритма аутентифицированного шифрования Р 1323565.1.024-2019 для блочного шифра Магма
::

	int ak_aead_create_mgm_magma(ak_aead ctx, bool_t crf)

*Использование функции можно увидеть в следующем примере:* `example-8.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-8.c>`_.

	2. Создание контекста алгоритма аутентифицированного шифрования Р 1323565.1.024-2019 для блочного шифра Кузнечик
::

	int ak_aead_create_mgm_kuznechik(ak_aead ctx, bool_t crf)
	
*Использование функции можно увидеть в следующем примере:* `example-9.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-9.c>`_.
	
	3. Создание контекста алгоритма аутентифицированного шифрования xtsmac для блочного шифра Магма
::

	int ak_aead_create_xtsmac_magma(ak_aead ctx, bool_t crf)
	
*Использование функции можно увидеть в следующем примере:* `example-10.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-10.c>`_.

	4. Создание контекста алгоритма аутентифицированного шифрования ctr-cmac для блочного шифра Магма
:: 

	int ak_aead_create_ctr_cmac_magma(ak_aead ctx, bool_t crf)
	
*Использование функции можно увидеть в следующем примере:* `example-11.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-11.c>`_	.
	
	5. Создание контекста алгоритма аутентифицированного шифрования ctr-cmac для блочного шифра Кузнечик
::

	int ak_aead_create_ctr_cmac_kuznechik(ak_aead ctx, bool_t crf)
	
*Использование функции можно увидеть в следующем примере:* `example-12.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-12.c>`_.

	6. Создание контекста алгоритма аутентифицированного шифрования ctr-nmac для блочного шифра Магма
:: 

	int ak_aead_create_ctr_nmac_magma(ak_aead ctx, bool_t crf)

*Использование функции можно увидеть в следующем примере:* `example-13.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-13.c>`_.

	7. Создание контекста алгоритма аутентифицированного шифрования ctr-nmac для блочного шифра Кузнечик
::

	int ak_aead_create_ctr_nmac_kuznechik(ak_aead ctx, bool_t crf)

*Использование функции можно увидеть в следующем примере:* `example-14.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-14.c>`_

	8. Создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Магма и функции хеширования Стрибог256
::

	int ak_aead_create_ctr_hmac_magma_streebog256(ak_aead ctx, bool_t crf)
	
*Использование функции можно увидеть в следующем примере:* `example-15.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-15.c>`_	.
	
	9. Создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Кузнечик и функции хеширования Стрибог256
::

	int ak_aead_create_ctr_hmac_kuznechik_streebog256(ak_aead ctx, bool_t crf)

*Использование функции можно увидеть в следующем примере:* `example-16.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-16.c>`_.

	10. Создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Магма и функции хеширования Стрибог512
::
	
	int ak_aead_create_ctr_hmac_magma_streebog512(ak_aead ctx, bool_t crf)
	
*Использование функции можно увидеть в следующем примере:* `example-17.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-17.c>`_.

	11. Создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Кузнечик и функции хеширования Стрибог512
::

	int ak_aead_create_ctr_hmac_kuznechik_streebog512(ak_aead ctx, bool_t crf)
	
*Использование функции можно увидеть в следующем примере:* `example-18.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-18.c>`_.

	12. Создание контекста алгоритма аутентифицированного шифрования по заданному oid
::

	int ak_aead_create_oid(ak_aead ctx, bool_t crf, ak_oid oid)
	
	/* Возможные значения OID для aead шифрования:
    
    	"mgm-magma"
    	"mgm-kuznechik"
    	"xtsmac-magma"
    	"ctr-cmac-magma"
    	"ctr-cmac-kuznechik"
    	"ctr-hmac-magma-streebog256"
    	"ctr-hmac-magma-streebog512"
    	"ctr-hmac-kuznechik-streebog256"
    	"ctr-hmac-kuznechik-streebog512"
    	"ctr-nmac-magma"
    	"ctr-nmac-kuznechik"
    
    	Все OID аналогичны заданию функции напрямую */

*Использование функции можно увидеть в следующем примере:* `example-19.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-19.c>`_.


Как инициализировать ключи аутентификации и шифрования?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Инициалиировать ключи шифрования и аутентификации можно либо двумя отдельными функциями, либо одной общей функцией.

	1. Инициализация отдельными функциями:
::

	int ak_aead_set_encrypt_key(
               		ak_aead ctx,           /* Контекст алгоритма аутентифицированного шифрования */
    			const ak_pointer key,  /* Область памяти, в которой хранится 
			значение ключа шифрования */
    			const size_t size      /* Размер ключа шифрования (в октетах) */
    			)
			
	ak_aead_set_auth_key(
                	ak_aead ctx,           /* Контекст алгоритма аутентифицированного шифрования */
    			const ak_pointer key,  /* Область памяти, в которой хранится 
			значение ключа аутентификации (имитозащиты) */
    			const size_t size      /* Размер ключа аутентификации (в октетах) */
    			)
			
*Использование функции можно увидеть в следующем примере:* `example-8.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-8.c>`_.

	2. Инициализация общей функцией:
::

	int ak_aead_set_keys(
                	ak_aead ctx,            /* Контекст алгоритма аутентифицированного шифрования */
    			const ak_pointer key,   /* Область памяти, в которой хранится 
			значение ключа шифрования */
    			const size_t size,      /* Размер ключа шифрования (в октетах) */
    			const ak_pointer key,   /* Область памяти, в которой хранится 
			значение ключа аутентификации (имитозащиты) */
    			const size_t size       /* Размер ключа аутентификации (в октетах) */
    			)
			
*Использование функций можно увидеть в следующих примерах:* `example-9.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-9.c>`_, `example-10.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-10.c>`_, `example-11.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-11.c>`_, `example-12.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-12.c>`_, `example-13.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-13.c>`_, `example-14.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-14.c>`_, `example-15.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-15.c>`_, `example-16.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-16.c>`_, `example-17.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-17.c>`_, `example-18.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-18.c>`_, `example-19.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-19.c>`_.


Как зашифровать/расшифровать данные с помощью аутентифицируемого шифрования с одновременным вычислением/проверки имитовставки?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зашифровать текст аутентифицируемым шифрованием можно с помощью следующей функции
::

	int ak_aead_encrypt(
    			ak_aead ctx, /* контекст алгоритма аутентифицированного шифрования */
    			const ak_pointer adata,      /* указатель на ассоциированные (незашифровываемые) данные */
    			const size_t adata_size,          /* длина ассоциированных данных в октетах */
    			const ak_pointer in, /* указатель на зашифровываемые данные */
    			ak_pointer out, /* указатель на зашифрованные данные */
    			const size_t size,          /* размер зашифровываемых данных в октетах */
    			const ak_pointer iv,          /* указатель на синхропосылку */
    			const size_t iv_size,   /* длина синхропосылки в октетах */
    			ak_pointer icode,         /* указатель на область памяти, куда будет помещено значение имитовставки */
    			const size_t icode_size   /* ожидаемый размер имитовставки в байтах */
    			))
			
Расшифровать текст аутентифицируемым шифрованием можно с помощью функции, аналогичной зашифрованию:
:: 

	int ak_aead_decrypt(
    			ak_aead ctx, /* контекст алгоритма аутентифицированного шифрования */
    			const ak_pointer adata,      /* указатель на ассоциированные (незашифровываемые) данные */
    			const size_t adata_size,          /* длина ассоциированных данных в октетах */
    			const ak_pointer in, /* указатель на расшифровываемые данные */
    			ak_pointer out, /* указатель на расшифрованные данные */
    			const size_t size,          /* размер зашифровываемых данных в октетах */
    			const ak_pointer iv,          /* указатель на синхропосылку */
    			const size_t iv_size,   /* длина синхропосылки в октетах */
    			ak_pointer icode,         /* указатель на область памяти, где расположена проверяемая имитовставки */
    			const size_t icode_size   /* ожидаемый размер имитовставки в байтах */
    			))

*Использование функций можно увидеть в следующих примерах:* `example-8.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-8.c>`_, `example-9.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-9.c>`_, `example-10.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-10.c>`_, `example-11.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-11.c>`_, `example-12.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-12.c>`_, `example-13.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-13.c>`_, `example-14.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-14.c>`_, `example-15.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-15.c>`_, `example-16.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-16.c>`_, `example-17.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-17.c>`_, `example-18.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-18.c>`_, `example-19.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-19.c>`_.


ЭЛЕКТРОННАЯ ПОДПИСЬ
----------------------------------------------------
Процесс подписи данных выработанной электронной подписью:

	1. Определение типа данных для подписи (теоретическая часть) и выделение памяти под данные (если необходимо);
	
	2. Создание контекста секретного ключа электронной подписи ``ak_signkey``;
	
	3. Инициализация секретного ключа;
	
	4. В случае, если необходима проверка подписи - создание контекста открытого ключа электронной подписи ``ak_verifykey`` и его инициализация;
	
	5. Подпись данных;
	
	6. Проверка подписи в случае необходимости;
	
	7. Уничтожение структур ``ak_signkey`` и ``ak_verifykey``.
	

Как создать контекст секретного ключа электронной подписи?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Контекст секретного ключа электронной подписи хранится с помощью структуры ``ak_signkey``.

После завершения работы с данной структурой - ее **необходимо уничтожить** функцией ``int ak_signkey_destroy( ak_signkey sctx )``!

Создание структуры контекста секретного ключа ЭП возможно с помощью функции:
::

	int ak_signkey_create_str(
			ak_signkey sk,
			const char *ni /* строка, содержащая имя или идентификатор 
    			эллиптической кривой, на которой будет реализован криптографический алгоритм */
     			)
			
*Использование функции можно увидеть в следующих примерах:* `example-20 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-20.c>`_, `example-21 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-21.c>`_, `example-22 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-22.c>`_.


Как создать секретный ключ электронной подписи?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Создать секретный ключ электронной подписи можно несколькими способами:

	1. Инициализировать секретный ключ случайчайным (псевдо-случайным) значением:
::

	int ak_signkey_set_key_random(
    			ak_signkey sctx, /* контекст секретного ключа алгоритма электронной подписи */
    			ak_random generator /*контекст генератора случайных чисел*/
 			)
			
*Использование функции можно увидеть в следующем примере:* `example-20 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-20.c>`_.
				
	2. Инициализировать секретный ключ константным значением:
::

	int ak_signkey_set_key(
    			ak_signkey sctx, /* контекст секретного ключа алгоритма электронной подписи */
    			const ak_pointer ptr, /* указатель на область памяти, содержащей значение 
    			секретного ключа */
    			const size_t size /* размер ключа в байтах */
    			)

*Использование функции можно увидеть в следующих примерах:* `example-21 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-21.c>`_, `example-22 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-22.c>`_.
	

Как создать открытый ключ электронной подписи?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Для начала необходимо создать структуру ``ak_verifykey`` для хранения открытого ключа ЭП.

После завершения работы с данной структурой - ее **необходимо уничтожить** функцией ``int ak_verifykey_destroy( ak_verifykey pctx )``!

После этого необходимо инициализировать открытый ключ ЭП с помощью функции:
::

	int ak_verifykey_create_from_signkey(
		ak_verifykey pctx, /* контекст открытого ключа ЭП */
		ak_signkey sctx /* контекст секретного ключа ЭП */
		)

*Использование функции можно увидеть в следующих примерах:* `example-21 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-21.c>`_, `example-22 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-22.c>`_.
	

Как подписать данные электронной подписью?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
В зависимости от типа подписываемых даннных необходимо использовать различные функции.

	1. Подпись данных с помощью вычисленного хеш-кода подписываемого сообщения:
::

	void ak_signkey_sign_const_values(
    			ak_signkey sctx, /* контекст секретного ключа алгоритма электронной подписи */
    			ak_uint64 *k, /* степень кратности точки \f$ P \f$ */
    			ak_uint64 *e, /* целое число, соотвествующее хеш-коду подписываемого сообщения */
    			ak_pointer out /* массив, куда помещается результат */
    			)
			

*Использование функции можно увидеть в следующем примере:* `example-20 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-20.c>`_.

	2. Подпись строки данных:
::

	int ak_signkey_sign_ptr(
    			ak_signkey sctx, /* контекст секретного ключа алгоритма электронной подписи */
    			ak_random generator, /* генератор случайной последовательности,
    			используемой в алгоритме подписи */
    			const ak_pointer in, /* указатель на входные данные которые подписываются */
    			const size_t size, /* размер входных данных в байтах */
    			ak_pointer out, /* область памяти, куда будет помещена ЭП */
    			size_t out_size /* размер выделенной под выработанную ЭП памяти */
    			)
			

*Использование функции можно увидеть в следующем примере:* `example-21 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-21.c>`_.

	3. Подпись файла:
::

	int ak_signkey_sign_file(
    			ak_signkey sctx, /* контекст секретного ключа алгоритма электронной подписи */
    			ak_random generator, /* генератор случайной последовательности,
    			используемой в алгоритме подписи */
    			const char *filename, /* строка с именем файла для которого вычисляется 
    			электронная подпись */
    			ak_pointer out, /* область памяти, куда будет помещена ЭП */
    			size_t out_size /* размер выделенной под выработанную ЭП памяти */
    			)
			

*Использование функции можно увидеть в следующем примере:* `example-22 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-22.c>`_.


Как проверить электронную подпись?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аналогично самой подписи, для проверки ЭП необходимо использовать различные функции в зависимости от типа подписываемых даннных.

	1. Строка в качестве подписанных данных: 
::

	bool_t ak_verifykey_verify_ptr(
    			ak_verifykey pctx, /* контекст открытого ключа */
    			const ak_pointer in, /* область памяти для которой проверяется электронная подпись */
    			const size_t size, /* размер области памяти в байтах */
    			ak_pointer sign /* электронная подпись, для которой выполняется проверка */
    		 	)

*Использование функции можно увидеть в следующем примере:* `example-21 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-21.c>`_.

	2. Файл в качестве подписанных данных:
:: 

	bool_t ak_verifykey_verify_file(
    			ak_verifykey pctx, /* контекст открытого ключа */
    			const char *filename, /* имя файла, для которого проверяется подпись */
    			ak_pointer sign /* электронная подпись, для которой выполняется проверка */
    			)
			
*Использование функции можно увидеть в следующем примере:* `example-22 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-22.c>`_.

	3. Хеш-код сообщения в качестве подписанных данных:
::

	bool_t ak_verifykey_verify_hash( 
			ak_verifykey pctx, /* контекст открытого ключа */
                        const ak_pointer hash, /* хеш-код сообщения (последовательность байт), 
			для которого проверяется электронная подпись */
			const size_t hsize, /* размер хеш-кода, в байтах */
			ak_pointer sign /* электронная подпись, для которой выполняется проверка */
			)


ДРУГИЕ АЛГОРИТМЫ
----------------------------------------------------

Как кодировать в base64?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Кодирование в base64 осуществляется с помощью функции:
::

	void ak_base64_encodeblock( 
			ak_uint8 *in, /* указатель на кодируемые данные */
			ak_uint8 *out, /* указатель на данные, куда помещается результат */
			int len /* количество кодируемых октетов (от одного до трех) */
			)

*Использование функции можно увидеть в следующем примере:* `example-32 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-32.c>`_.


Как взять хэш от данных?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Для хэширования данных необходимо создать контекст функции хэширования ``ak_hash``. 

После завершения работы с данной структурой - ее **необходимо уничтожить** функцией ``int ak_hash_destroy( ak_hash hctx )``!

После создания необходимо инициализировать контекст функции хэширования. Это можно сделать несколькими способами:

	1. Инициализация контекста алгоритма бесключевого хеширования, регламентируемого стандартом ГОСТ Р 34.11-2012, с длиной хешкода, равной 256 бит 	(функция Стрибог256):
::

	int ak_hash_create_streebog256( ak_hash hctx /* Контекст функции хеширования */)
	
*Использование функции можно увидеть в следующем примере:* `example-24.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-24.c>`_.	
	
	2. Инициализация контекста алгоритма бесключевого хеширования, регламентируемого стандартом ГОСТ Р 34.11-2012, с длиной хешкода, равной 512 бит 	(функция Стрибог512):
::

	int ak_hash_create_streebog512( ak_hash hctx /* Контекст функции хеширования */)

*Использование функции можно увидеть в следующем примере:* `example-25.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-25.c>`_.

	3. Инициализация контекста алгоритма по его OID:
::

	int ak_hash_create_oid( 
			ak_hash hctx, /* Контекст функции хеширования */
			ak_oid oid /* OID алгоритма бесключевого хеширования */
			)

*Использование функции можно увидеть в следующем примере:* `example-26.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-26.c>`_.


Для хэширования данных необходимо использовать следующие функции, в зависимости от типа хэшируемых данных:

	1. Хэш от строки:
::

	int ak_hash_ptr( 
			ak_hash hctx, /* Контекст функции хеширования */
			const ak_pointer in, /* Указатель на входные данные для которых вычисляется хеш-код */
                        const size_t size, /* Размер входных данных в байтах */
			ak_pointer out, /* Область памяти, куда будет помещен результат. Память должна быть заранее выделена */
			const size_t out_size /* Размер области памяти (в октетах), в которую будет помещен результат */
			)
			
*Использование функции можно увидеть в следующих примерах:* `example-25.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-25.c>`_, `example-26.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-26.c>`_.
		
	2. Хэш от файла:
::

	int ak_hash_file( 
			ak_hash hctx, 
			const char * filename, 
			ak_pointer out, 
			const size_t out_size 
			)
			

Как вычислить контрольную сумму?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Вычисление 32-битной контрольной суммы возможно с помощью функции которая вычисляет КС по алгоритму Флетчера:
::

	int ak_ptr_fletcher32( 
			ak_const_pointer data, /* Указатель на область пямяти, для которой вычисляется контрольная сумма */
			const size_t size, /* Размер области (в октетах) */
			ak_uint32 *out /* Область памяти куда помещается результат */
			)
	
	
Или с помощью функции, работающей по модифицированному алгоритму Флетчера, заменяющему обычное модульное сложение на операцию поразрядного сложения по модулю 2:
::

	int ak_ptr_fletcher32_xor( 
			ak_const_pointer data, /* Указатель на область пямяти, для которой вычисляется контрольная сумма */
			const size_t size, /* Размер области (в октетах) */
			ak_uint32 *out /* Область памяти куда помещается результат */
			)

*Использование функций можно увидеть в следующих примерах:* `example-31.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-31.c>`_ и `example-30.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-30.c>`_ соответственно.



ВСПОМОГАТЕЛЬНЫЕ БИБЛИОТЕЧНЫЕ ФУНКЦИИ
----------------------------------------------------
Как найти OID по имени?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Если необходимо найти объекта - можно воспользоваться следующими функциями:

	1. Поиск по имени объекта
:: 

	ak_oid ak_oid_find_by_name( 
			const char *name /* строка, содержащая символьное 
			(человекочитаемое) имя криптографического механизмаили параметра */ 
			)
			
*Использование функции можно увидеть в следующих примерах:* `example-1 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-1.c>`_, `example-2 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-2.c>`_.			
			
			
	2. Поиск по режиму работы криптографического механизма
:: 

	ak_oid ak_oid_find_by_mode( 
			const oid_modes_t mode /* режим работы криптографического механизма */
			)

*Использование функции можно увидеть в следующем примере:* `example-33 <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-33.c>`_.



Как выработать случайное (псевдо-случайное) значение?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Контекст генератора случайных (псевдо-случайных) значений хранится в структуре ``ak_random``.

После завершения работы с данной структурой - ее **необходимо уничтожить** функцией ``int ak_random_destroy( ak_random rnd )``!

Несколько вариантов:

	1. Линейный конгруэнтный генератор (Linear congruential generator, lcg):
::

	int ak_random_create_lcg(ak_random generator)

*Использование функции можно увидеть в следующем примере:* `example-3.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-3.c>`_.

	2. Нелинейный конгруэнтный генератор с обратной квадратичной связью (Nonlinear-feedback shift register, nlfsr) без параметров:
::
	
	int ak_random_create_nlfsr(ak_random generator)
	
	/* На самом деле данная функция вызывает другую с константными параметрами:
	
	ak_random_create_nlfsr_with_params( generator, 21, 849314 );
	
	*/
	
*Использование функции можно увидеть в следующих примерах:* `example-4.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-4.c>`_, `example-7.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-7.c>`_.
	
	3. Нелинейный конгруэнтный генератор с обратной квадратичной связью (Nonlinear-feedback shift register, nlfsr) с параметрами:
::
	
	 int ak_random_create_nlfsr_with_params( ak_random generator,
			size_t size, /* размер нелинейного регистра, не должен быть более 32-х */
			ak_uint64 linear_part /* код линейной части обратной связи */
			)
	
*Описание функции можно найти в файле* `ak_random.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/source/ak_random.c>`_ *на строке 697*.
	
	4. Генератор по заданному OID алгоритма генерации псевдо-случайных чисел:
:: 

	int ak_random_create_oid( ak_random rnd, 
			ak_oid oid /* OID генератора */
			

*Использование функции можно увидеть в следующем примере:* `example-20.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-20.c>`_


Как сравнить две области памяти одинакового размера?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Произвести сравнение двух областей памяти одинакового размера можно с помощью встроенной функции библиотеки 

``bool_t ak_ptr_is_equal( ak_const_pointer left, ak_const_pointer right, const size_t size )``.

*Пример использования можно найти в файле ak_tools.c на строке 633:* `ak_tools.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/source/ak_tools.c>`_
	

Как открыть файл на чтение?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Для хранения информации о файле в библиотеке определена структура ``ak_file``. 

Файл на чтение можно открыть с помощью функции 

``int ak_file_open_to_read( ak_file file, const char *filename )``.

Чтобы прочитать из файла необходимо использовать функцию 

``ssize_t ak_file_read( ak_file file, ak_pointer buffer, size_t size )``.

*Использование функций можно увидеть в следующем примере:* `example-23.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-23.c>`_


Как прочитать пароль из консоли?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Чтение пароля из консоли реализовано в библиотеке с помощью фукнции: 
::

	ssize_t ak_password_read( 
			char *pass, /* Строка, в которую будет помещен пароль */
			const size_t psize /* Максимально возможная длина пароля */
			)

*Использование функции можно увидеть в следующем примере:* `example-28.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-28.c>`_


Как прочитать строку из консоли?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Чтение строки из консоли реализовано в библиотеке с помощью фукнции:
::

	 int ak_string_read( 
	 		const char *message, /* предложение, которое печатается перед вводом строки */
			char *string, /* буффер, в который помещается введенное значение */
			size_t *size /* переменная, в которой возвращается размер введенной строки */
			)

*Использование функции можно увидеть в следующем примере:* `example-29.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-29.c>`_


Как регулировать уровень аудита?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Все сообщения библиотеки могут быть разделены на три уровня.


	1. Первый уровень аудита определяется константой ``ak_log_none``. 

На этом уровне выводятся только сообщения об ошибках.


	2. Второй уровень аудита определяется константой ``ak_log_standard``. 
	
На этом уровне выводятся все сообщения из первого уровня, а также сообщения, регламентируемые существующей нормативной базой.


	3. Третий (максимальный) уровень аудита определяется константой ``ak_log_maximum``.

На этом уровне выводятся все сообщения, доступные на первых двух уровнях, а также сообщения отладочного характера, позволяющие проследить логику работы функций библиотеки.

	* Выставить уровень аудита можно с помощью функции ``int ak_log_set_level( int level )``. В качестве аргумента в данную фунцию передается один из трех указанных выше уровней.

Для вывода сообщений об ошибке необходимо использовать функции, которая формируют строку с сообщением специального вида и выводит данную строку в установленное устройство аудита (консоль, демон syslog и т.п.).
::

	int ak_error_message( 
			const int code, /* Код ошибки */
			const char *function, /* Читаемое (понятное для пользователя) сообщение */
			const char *message /* Имя функции, вызвавшей ошибку */
			)
		
*Использование функции можно увидеть в следующем примере:* `example-26.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-26.c>`_.

Низкоуровневая функция вывода строк в устройство аудита может быть установлена
с помощью ``ak_log_set_function()``. Примерами устанавливаемых функций являются:


   	* ``ak_function_log_stderr()``, реализующая вывод в стандартный поток вывода ошибок,
    	* ``ak_function_log_syslog()``, реализующая вывод в демон аудита syslog.


Выставить уровень аудита можно с помощью функции ``int ak_log_set_level( int level )``. В качестве аргумента в данную фунцию передается один из трех уровней:

	* Первый уровень аудита - ``ak_log_none`` - выводятся олько сообщения об ошибках;
	* Второй уровень аудита - ``ak_log_standard`` - выводятся все сообщения из первого уровня, а также сообщения, регламентируемые существующей 		нормативной базой;
	* Третий (максимальный) уровень - ``ak_log_maximum`` - выводятся все сообщения, доступные на первых двух уровнях, а также сообщения отладочного 	характера, позволяющие проследить логику работы функций библиотеки.
   
*Использование функции можно увидеть в следующих примерах:* `example-20.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-20.c>`_, `example-21.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-20.c>`_, `example-22.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-20.c>`_.


Как преобразовать строку шестнадцатиричных символов в массив данных?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Для преобразования необходимо использовать библиотечную функцию:
::

	int ak_hexstr_to_ptr( 
			const char *hexstr, /* Строка символов */
			ak_pointer ptr, /* Указатель на область памяти (массив), в которую будут размещаться данные */
			const size_t size, /* Максимальный размер памяти (в байтах), которая может быть помещена в массив */
			const bool_t reverse /* Последовательность считывания байт в память */
			)

*Использование функции можно увидеть в следующем примере:* `example-27.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-27.c>`_

ОПИСАНИЕ ПРИМЕРОВ
------------------------------
`example-1.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-1.c>`_  	
	* создание секретного ключа алгоритма Кузнечик по OID;
	* инициализация контекста ключа значением, выработанным из заданного значения пароля; 
	* зашифрование и расшифрование текста в режиме простой замены (ecb).

`example-2.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-2.c>`_ 
	* создание секретного ключа алгоритма Магма по OID;
	* инициализация контекста ключа значением, выработанным из заданного значения пароля; 
	* зашифрование и расшифрование текста в режиме ctr.

`example-3.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-3.c>`_
	* создание секретного ключа алгоритма Кузнечик; 
	* инициализация контекста ключа случайным (псевдо-случайным) значением, выработанным генератором псевдо-случайных чисел (lcg); 
	* зашифрование и расшифрование текста в режиме ofb.

`example-4.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-4.c>`_
	* создание секретного ключа алгоритма Магма; 
	* инициализация контекста ключа случайным (псевдо-случайным) значением, выработанным генератором псевдо-случайных чисел (nlfsr); 
	* зашифрование и расшифрование текста в режиме cfb.

`example-5.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-5.c>`_
	* создание секретного ключа алгоритма Магма; 
	* инициализация контекста ключа значением, содержащимся в области памяти; 
	* зашифрование и расшифрование текста в режиме acpkm. 

`example-6.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-6.c>`_ 
	* создание секретного ключа алгоритма Магма; 
	* инициализация контекста ключа значением, содержащимся в области памяти; 
	* зашифрование и расшифрование текста в режиме xtsmac. 

`example-7.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-7.c>`_
	* создание секретного ключа алгоритма Кузнечик; 
	* инициализация контекста ключа случайным (псевдо-случайным) значением, выработанным генератором псевдо-случайных чисел (nlfsr); 
	* зашифрование и расшифрование текста в режиме cbc. 

`example-8.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-8.c>`_
	* создание контекста алгоритма аутентифицированного шифрования Р 1323565.1.024-2019 для блочного шифра Магма; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации по отдельности; 
	* зашифрование данных с одновременным вычислением имитовставки.

`example-9.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-9.c>`_
	* создание контекста алгоритма аутентифицированного шифрования Р 1323565.1.024-2019 для блочного шифра Кузнечик; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки.

`example-10.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-10.c>`_
	* создание контекста алгоритма аутентифицированного шифрования xtsmac для блочного шифра Магма; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки.

`example-11.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-11.c>`_
	* создание контекста алгоритма аутентифицированного шифрования ctr-cmac для блочного шифра Магма; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки.

`example-12.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-12.c>`_
	* создание контекста алгоритма аутентифицированного шифрования ctr-cmac для блочного шифра Кузнечик; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации;
	* зашифрование данных с одновременным вычислением имитовставки. 

`example-13.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-13.c>`_
	* создание контекста алгоритма аутентифицированного шифрования ctr-nmac для блочного шифра Магма; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки. 

`example-14.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-14.c>`_
	* создание контекста алгоритма аутентифицированного шифрования ctr-nmac для блочного шифра Кузнечик; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки. 

`example-15.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-15.c>`_
	* создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Магма и функции хеширования Стрибог256; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки.

`example-16.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-16.c>`_
	* создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Кузнечик и функции хеширования Стрибог256; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки.

`example-17.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-17.c>`_
	* создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Магма и функции хеширования Стрибог512; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки.

`example-18.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-18.c>`_
	* создание контекста алгоритма аутентифицированного шифрования ctr-hmac для блочного шифра Кузнечик и функции хеширования Стрибог512;
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки. 

`example-19.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-19.c>`_
	* создание контекста алгоритма аутентифицированного шифрования по заданному OID; 
	* инициализация контекста алгоритма aead значениями ключей шифрования и аутентификации; 
	* зашифрование данных с одновременным вычислением имитовставки.

`example-20.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-20.c>`_
	* использование электронной подписи на основе вычисленного хеш-кода подписываемого сообщения;
	* выставление уровня аудита;
	* инициализация контекста секретного ключа алгоритма электронной подписи случайным (псевдо-случайным) значением, выработанным генератором 		псевдо-случайных чисел (lcg).
	
`example-21.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-21.c>`_
	* использование электронной подписи для константного значения строки;
	* выставление уровня аудита;
	* инициализация контекста секретного ключа алгоритма электронной подписи константным значением;
	* проверка электронной подписи строки.

`example-22.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-22.c>`_
	* использование электронной подписи для исполняемого файла;
	* выставление уровня аудита;
	* инициализация контекста секретного ключа алгоритма электронной подписи константным значением;
	* проверка электронной подписи файла.
	
`example-23.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-23.c>`_
	* открытие файла на чтение;
	* чтение электронной подписи из файла.
	
`example-24.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-24.c>`_
	* инициализация контекста алгоритма бесключевого хеширования, регламентируемого стандартом ГОСТ Р 34.11-2012, с длиной хешкода, равной 256 бит 		(функция Стрибог256);
	* хэширование константной строки.

`example-25.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-25.c>`_
	* инициализация контекста алгоритма бесключевого хеширования, регламентируемого стандартом ГОСТ Р 34.11-2012, с длиной хешкода, равной 512 бит 		(функция Стрибог512);
	* хэширование константной строки. 
	
`example-26.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-26.c>`_
	* инициализация контекста алгоритма бесключевого хеширования, регламентируемого стандартом ГОСТ Р 34.11-2012, с длиной хешкода, равной 512 бит 		(функция Стрибог512) (поиск алгоритма по его OID);
	* хэширование константной строки.
	
`example-27.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-27.c>`_
	* преобразование строки символов, содержащую последовательность шестнадцатеричных цифр, в массив данных.
	
`example-28.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-28.c>`_
	* чтение пароля из консоли.

`example-29.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-29.c>`_
	* чтение строки символов из консоли.

`example-30.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-30.c>`_
	* вычисление 32-битной контрольной суммы модифицированным алгоритмом Флетчера. 
	
`example-31.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-31.c>`_
	* вычисление 32-битной контрольной суммы алгоритмом Флетчера.

`example-32.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-32.c>`_
	* реализация преобразования строки алгоритмом base64.
	
`example-33.c <https://github.com/yupanasenko/libakrypt_faq/blob/master/examples/faq/example-33.c>`_
	* выработка контекста алгоритма аутентифицированного шифрования;
	* выработка имитовставки;
	* зашифрование и расшифрование текста алгоритмом ctr apckm.

