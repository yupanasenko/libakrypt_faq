/* ----------------------------------------------------------------------------------------------- */
/*  Copyright (c) 2014 - 2019 by Axel Kenzo, axelkenzo@mail.ru                                     */
/*                                                                                                 */
/*  Файл ak_sign.h                                                                                 */
/*  - содержит описание функций для работы с электронной подписью.                                 */
/* ----------------------------------------------------------------------------------------------- */
#ifndef    __AK_SIGN_H__
#define    __AK_SIGN_H__

/* ----------------------------------------------------------------------------------------------- */
 #include <ak_hmac.h>
 #include <ak_asn1.h>

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Секретный ключ алгоритма выработки электронной подписи ГОСТ Р 34.10-2012.

   Ключ может рассматриваться в качестве секретного ключа как для действующего стандарта
   ГОСТ Р 34.10-2012, так и для предыдущей редакции 2001 года. Кроме того, данный контекст
   секретного ключа может быть применим для любого асимметричного криптографического механизма,
   использующего вычисления с эллиптическими кривыми в короткой форме Вейерштрасса, либо
   в искривленной форме Эдвардса. Кривые указанных форм поддерживаются отечественными
   рекомендациями Р 1323565.024-2019.                                                              */
/* ----------------------------------------------------------------------------------------------- */
 typedef struct signkey {
 /*! \brief контекст секретного ключа */
  struct skey key;
 /*! \brief контекст функции хеширования */
  struct hash ctx;
 /*! \brief ASN.1 дерево, содержащее в себе последовательность расширенных имен
    владельца ключа (согласно ITU-T X.509) */
  ak_tlv name;
 /*! \brief номер открытого ключа, выработанного из данного секретного ключа. */
  ak_uint8 verifykey_number[32];
} *ak_signkey;

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция создания контекста секретного ключа электронной подписи. */
 typedef int ( ak_function_signkey_context_create ) ( ak_signkey );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Инициализация контекста секретного ключа алгоритма ГОСТ Р 34.10-2012. */
 int ak_signkey_context_create( ak_signkey , const ak_wcurve );
/*! \brief Инициализация контекста секретного ключа алгоритма ГОСТ Р 34.10-2012. */
 int ak_signkey_context_create_str( ak_signkey , const char * );
/*! \brief Инициализация контекста секретного ключа алгоритма ГОСТ Р 34.10-2012
   с параметрами эллиптической кривой по-умолчанию. */
 int ak_signkey_context_create_streebog256( ak_signkey );
/*! \brief Инициализация контекста секретного ключа алгоритма ГОСТ Р 34.10-2012
   с параметрами эллиптической кривой по-умолчанию. */
 int ak_signkey_context_create_streebog512( ak_signkey );
/*! \brief Инициализация контекста секретного ключа алгоритма выработки электронной подписи
    по заданному идентификатору алгоритма. */
 int ak_signkey_context_create_oid( ak_signkey , ak_oid );
/*! \brief Присвоение контексту секретного ключа указателя на эллиптическую кривую. */
 int ak_signkey_context_set_curve( ak_signkey , const ak_wcurve );
/*! \brief Присвоение контексту секретного ключа указателя на эллиптическую кривую. */
 int ak_signkey_context_set_curve_str( ak_signkey sctx, const char * );
/*! \brief Уничтожение контекста секретного ключа. */
 int ak_signkey_context_destroy( ak_signkey );
/*! \brief Освобождение памяти из под контекста секретного ключа. */
 ak_pointer ak_signkey_context_delete( ak_pointer );
/*! \brief Размер области памяти, которую занимает электронная подпись. */
 size_t ak_signkey_context_get_tag_size( ak_signkey );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Присвоение секретному ключу электронной подписи константного значения. */
 int ak_signkey_context_set_key( ak_signkey , const ak_pointer , const size_t );
/*! \brief Присвоение секретному ключу электронной подписи случайного значения. */
 int ak_signkey_context_set_key_random( ak_signkey , ak_random );
/*! \brief Функция добавляет к расширенному имени владельца ключа новую строку. */
 int ak_signkey_context_add_name_string( ak_signkey , const char * , const char * );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Выработка электронной подписи для фиксированного значения случайного числа и вычисленного
    заранее значения хеш-функции. */
 void ak_signkey_context_sign_const_values( ak_signkey , ak_uint64 * , ak_uint64 * , ak_pointer );
/*! \brief Выработка электронной подписи для вычисленного заранее значения хеш-функции. */
 int ak_signkey_context_sign_hash( ak_signkey , ak_pointer , size_t , ak_pointer , size_t );
/*! \brief Выработка электронной подписи для заданной области памяти. */
 int ak_signkey_context_sign_ptr( ak_signkey , const ak_pointer , const size_t , ak_pointer , size_t );
/*! \brief Выработка электронной подписи для заданного файла. */
 int ak_signkey_context_sign_file( ak_signkey , const char * , ak_pointer , size_t );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Открытый ключ алгоритма проверки электронной подписи ГОСТ Р 34.10-2012.

   Ключ представляет собой объединение точки эллиптической кривой, а также ряда параметров: номера
   ключа, обобщенного имени владельца, времени действия и т.п., используемых при помещении ключа
   в контейнер или сертификат.

   Ключ может рассматриваться в качестве открытого ключа как для действующего стандарта
   ГОСТ Р 34.10-2012, так и для предыдущей редакции 2001 года. Кроме того, данный контекст
   открытого ключа может быть применим для любого асимметричного криптографического механизма,
   использующего вычисления с эллиптическими кривыми в короткой форме Вейерштрасса, либо
   в искривленной форме Эдвардса. Кривые указанных форм поддерживаются отечественными
   рекомендациями Р 1323565.024-2019.                                                              */
/* ----------------------------------------------------------------------------------------------- */
 typedef struct verifykey {
 /*! \brief контекст функции хеширования */
  struct hash ctx;  
 /*! \brief уникальный номер открытого ключа */
  ak_uint8 number[32];
 /*! \brief контекст эллиптической кривой */
  ak_wcurve wc;
 /*! \brief OID алгоритма, для которого используется ключ;
    в случае электронной подписи используется идентификтор алгоритма проверки подписи */
  ak_oid oid;
 /*! \brief точка кривой, являющаяся открытым ключом электронной подписи */
  struct wpoint qpoint;
 /*! \brief временной интервал использования ключа  */
  struct time_interval time;
 /*! \brief ASN.1 дерево, содержащее в себе последовательность расширенных имен
    владельца ключа (согласно ITU-T X.509) */
  ak_tlv name;
 /*! \brief флаги состояния ключа */
  ak_uint64 flags;
} *ak_verifykey;

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Инициализация контекста открытого ключа асимметричного криптографического алгоритма,
    в частности, алгоритма ГОСТ Р 34.10-2012. */
 int ak_verifykey_context_create( ak_verifykey , const ak_wcurve );
/*! \brief Инициализация контекста открытого ключа асимметричного криптографического алгоритма,
    в частности, алгоритма ГОСТ Р 34.10-2012. */
 int ak_verifykey_context_create_from_signkey( ak_verifykey , ak_signkey );
/*! \brief Функция устанавливает временной интервал действия открытого ключа. */
 int ak_verifykey_context_set_resource_time( ak_verifykey , time_t , time_t );
/*! \brief Функция вырабатывает номер открытого ключа. */
 int ak_verifykey_context_set_number( ak_verifykey );
/*! \brief Функция добавляет к расширенному имени владельца ключа новую строку. */
 int ak_verifykey_context_add_name_string( ak_verifykey , const char * , const char * );
/*! \brief Уничтожение контекста открытого ключа. */
 int ak_verifykey_context_destroy( ak_verifykey );
/*! \brief Освобождение памяти из под контекста открытого ключа. */
 ak_pointer ak_verifykey_context_delete( ak_pointer );
/*! \brief Проверка электронной подписи для вычисленного заранее значения хеш-функции. */
 bool_t ak_verifykey_context_verify_hash( ak_verifykey , const ak_pointer ,
                                                                       const size_t , ak_pointer );
/*! \brief Проверка электронной подписи для заданной области памяти. */
 bool_t ak_verifykey_context_verify_ptr( ak_verifykey , const ak_pointer ,
                                                                       const size_t , ak_pointer );
/*! \brief Проверка электронной подписи для заданного файла. */
 bool_t ak_verifykey_context_verify_file( ak_verifykey , const char * , ak_pointer );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Выполнение тестовых примеров для алгоритмов выработки и проверки электронной подписи */
 bool_t ak_signkey_test( void );

#endif
/* ----------------------------------------------------------------------------------------------- */
/*                                                                                      ak_sign.h  */
/* ----------------------------------------------------------------------------------------------- */
